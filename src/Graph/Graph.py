import pandas as pd

from APIRequester import *
from Utils.pathDefinitions import *
from sklearn.feature_extraction.text import CountVectorizer
# from Graph.Embedder import Embedder, LatentDirichletAllocationEmbedder
from Embedder import Embedder, LatentDirichletAllocationEmbedder


class Node:

    def __init__(self, json_node, infos):
        self.id = json_node['id']
        #print(json_node['abstract'])
        #list de mot qui sont nos embeddings
        self.infos = infos

    def to_str_file(self):
        str_info = ';'.join(str(x) for x in self.infos)
        return f"{self.id};{str_info}"

class Edge:

    def __init__(self, id_start, id_end):
        self.id_start, self.id_end = id_start, id_end

    def to_str_file(self):
        return f"{self.id_start} {self.id_end}"


class Graph():
    def __init__(self, json_graph, feature_extractor):
        self.nodes = []
        self.edges = []
        num_topics = 10  # Build LDA model
        self.embeddings_generator = feature_extractor
        self.emb = self.embeddings_generator.fit_transform(json_graph)
        self.construct_graph(json_graph)

    def generate_nodes(self, json_graph):
        for i, object in enumerate(json_graph):
            article = object['_source']
            self.nodes.append(Node(article, self.emb[i]))

    def generate_edges(self, json_graph):
        for i in json_graph:
            article = i['_source']
            references = article['references']
            for j in references:
                self.edges.append(Edge(article['id'], j))

    def construct_graph(self, json_graph):
        self.generate_nodes(json_graph)
        self.generate_edges(json_graph)

    def graph_to_file(self):
        os.makedirs(dataPath, exist_ok=True)
        with open(nodesPath, "w") as f:
            size = len(self.emb[0])
            header = ['id_article']
            for i in range(size):
                header.append(f"dim_{str(i)}")
            f.write(';'.join(header))
            f.write("\n")
            for i in self.nodes:
                f.write(i.to_str_file()+"\n")
        with open(edgesPath, "w") as f:
            for i in self.edges:
                f.write(i.to_str_file()+"\n")

    def graph_correlation(self):
        df = pd.read_table(nodesPath, delimiter=";", index_col=0, header=None)
        # df = df.transpose()
        print(df.head())

        # matrix = df.corr(method="pearson")
        # print(matrix)

if __name__ == '__main__':
    df = pd.read_table(nodesPath, delimiter=";", skiprows=1, header=None).T
    # df = df.transpose()
    df.columns = df.iloc[0]
    df.drop(0)
    print(df.head())

    matrix = df.corr(method="pearson")
    print(matrix)


    # apiRequester = APIRequester()
    # #g = Graph(apiRequester.request_articles("Romain Deveaud"))
    #
    # res = apiRequester.request_articles("Romain Deveaud", size=3)
    #
    # json_graph = {"Romain Deveaud": res}
    # g = Graph(res, LatentDirichletAllocationEmbedder())
    # g.graph_correlation()
    # g.graph_to_file()
    # graphBuilder = GraphBuilder(json_graph, childs_depth=1, verbose=True)
    # graph = graphBuilder.build_graph()

# {'id': 1892591945, 'authors': [{'name': 'Björn Döbel', 'id': 2079163294}, {'name': 'Robert Muschner', '        for i in json_graph:
#             article = i['_source']
#             self.nodes.append(Node(article)) 2493288214}, {'name': 'Hermann Härtig', 'id': 2128619729}], 'title': 'Resource-Aware Replication on Heterogeneous Multicores: Challenges and Opportunities.', 'year': 2014, 'n_citation': 1, 'page_start': '', 'page_end': '', 'doc_type': 'Repository', 'publisher': '', 'volume': '', 'issue': '', 'doi': '', 'references': [56227605, 164384110, 1977920247, 1996523225, 2034593585, 2095730858, 2098278566, 2100817684, 2102480715, 2104677471, 2110375867, 2125169487, 2143677609, 2144620757, 2151845324, 2152465173, 2404205649], 'fos': [{'name': 'Multithreading', 'w': 0.55954}, {'name': 'Computer science', 'w': 0.44149}, {'name': 'Microkernel', 'w': 0.58146}, {'name': 'Real-time computing', 'w': 0.4388}, {'name': 'Software', 'w': 0.47321}, {'name': 'Multi-core processor', 'w': 0.5353}, {'name': 'Distributed computing', 'w': 0.45934}, {'name': 'Vulnerability', 'w': 0.42196}], 'venue': {'raw': 'arXiv: Distributed, Parallel, and Cluster Computing', 'id': 2595101014, 'type': 'J'}, 'abstract': 'Decreasing hardware feature sizes and increasing heterogeneity in multicore hardware require software that can adapt to these platformsu0027 properties. We implemented ROMAIN, an OS service providing redundant multithreading on top of the FIASCO.OC microkernel to address the increasing unreliability of hardware. In this paper we review challenges and opportunities for ROMAIN to adapt to such multicore platforms in order to decrease execution overhead, resource requirements, and vulnerability against faults. ', 'nb_references': 17}

# {'id': 1996523225, 'authors': [{'name': 'Björn Döbel', 'org': 'TU Dresden, Dresden, Germany', 'id': 2079163294}, {'name': 'Hermann Härtig', 'org': 'TU Dresden, Dresden, Germany', 'id': 2128619729}, {'name': 'Michael Engel', 'org': 'TU Dortmund Dortmund, Germany', 'id': 2170261096}], 'title': 'Operating system support for redundant multithreading', 'year': 2012, 'n_citation': 43, 'page_start': '83', 'page_end': '92', 'doc_type': 'Conference', 'publisher': 'ACM', 'volume': '', 'issue': '', 'doi': '10.1145/2380356.2380375', 'references': [19830081, 21907718, 28319167, 56227605, 59073996, 109524315, 1555915743, 1579215414, 1745635051, 1850597240, 1878142362, 1905218906, 1941880258, 1966171750, 1967835393, 1968054699, 1972649107, 1977773183, 1980321276, 1980915257, 1983572666, 1993660990, 1996931099, 1998669042, 1999919743, 2001354277, 2006312753, 2010350305, 2012179240, 2013280342, 2016591508, 2019629740, 2031846229, 2033908103, 2034593585, 2036846060, 2037431929, 2037777200, 2040379684, 2042043230, 2042203635, 2045115736, 2054739713, 2061587924, 2069452468, 2072162984, 2072725684, 2076285066, 2081215702, 2081409107, 2083004950, 2083048258, 2083613288, 2091980304, 2094446102, 2095730858, 2095841921, 2096165352, 2096403564, 2099743021, 2099813257, 2100678175, 2100866260, 2101431901, 2102480715, 2104677471, 2105856410, 2110375867, 2112752650, 2114488210, 2115696550, 2116283852, 2116991991, 2117141734, 2117590013, 2118040280, 2118338314, 2118670307, 2120230074, 2120591095, 2122249806, 2122532513, 2123106754, 2123184511, 2125169487, 2127321265, 2127745296, 2129673456, 2130189691, 2131068811, 2132213430, 2134633067, 2136310957, 2137751461, 2137868744, 2138303065, 2139244298, 2139613807, 2140433506, 2140958850, 2140991542, 2143677609, 2144495364, 2144512449, 2144620757, 2144984544, 2145021036, 2145064068, 2145071552, 2145087641, 2145467766, 2147448476, 2147504831, 2148602057, 2149886445, 2150267144, 2151845324, 2152465173, 2152652532, 2152977845, 2156858199, 2158794422, 2162796604, 2164377668, 2166104547, 2169528473, 2169596872, 2170922286, 2171882483, 2176864362, 2281433966, 2285843422, 2293881818, 2296457158, 2395028494, 2398056170, 2402762800, 2402835606, 2404205649, 2406166723], 'fos': [{'name': 'Multithreading', 'w': 0.55346}, {'name': 'Computer science', 'w': 0.46022}, {'name': 'Real-time computing', 'w': 0.46208}, {'name': 'Redundancy (engineering)', 'w': 0.53102}, {'name': 'Software', 'w': 0.50908}, {'name': 'Temporal multithreading', 'w': 0.54081}, {'name': 'Software development', 'w': 0.52073}, {'name': 'Distributed computing', 'w': 0.47184}, {'name': 'Hardware compatibility list', 'w': 0.62424}, {'name': 'Reuse', 'w': 0.48218}, {'name': 'Microkernel', 'w': 0.50704}, {'name': 'Operating system', 'w': 0.47087}, {'name': 'Embedded system', 'w': 0.47584}], 'venue': {'raw': 'Embedded Software', 'id': 1162226489, 'type': 'C'}, 'abstract': 'In modern commodity operating systems, core functionality is usually designed assuming that the underlying processor hardware always functions correctly. Shrinking hardware feature sizes break this assumption. Existing approaches to cope with these issues either use hardware functionality that is not available in commercial-off-the-shelf (COTS) systems or poses additional requirements on the software development side, making reuse of existing software hard, if not impossible.   In this paper we present Romain, a framework that provides transparent redundant multithreading1 as an operating system service for hardware error detection and recovery. When applied to a standard benchmark suite, Romain requires a maximum runtime overhead of 30% for triple-modular redundancy (while in many cases remaining below 5%). Furthermore, our approach minimizes the complexity added to the operating system for the sake of replication. ', 'nb_references': 140, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 2035370633, 'authors': [{'name': 'Romain Deveaud', 'org': 'University of Glasogw, Glasgow, United Kingdom', 'id': 314381667}, {'name': 'M-Dyaa Albakour', 'org': 'University of Glasogw, Glasgow, United Kingdom', 'id': 209705036}, {'name': 'Craig Macdonald', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 2148910894}, {'name': 'Iadh Ounis', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 336997814}], 'title': 'Experiments with a Venue-Centric Model for Personalisedand Time-Aware Venue Suggestion', 'year': 2015, 'n_citation': 15, 'page_start': '53', 'page_end': '62', 'doc_type': 'Conference', 'publisher': 'ACM', 'volume': '', 'issue': '', 'doi': '10.1145/2806416.2806484', 'references': [36361912, 41368942, 180571615, 252349528, 1482214997, 1685426458, 1845198550, 1912123407, 1963499862, 1969629203, 1975674440, 1984189333, 1988144039, 2026532078, 2043282012, 2048641755, 2059512573, 2070075246, 2073013176, 2075548631, 2078527501, 2082260230, 2095124420, 2111216736, 2117446354, 2125055259, 2130570284, 2131133093, 2133990480, 2137862811, 2139809240, 2147197247, 2153756419, 2166646729, 2398973937, 2405827643, 2911964244], 'fos': [{'name': 'Data mining', 'w': 0.42438}, {'name': 'World Wide Web', 'w': 0.46547}, {'name': 'Collaborative filtering', 'w': 0.52663}, {'name': 'Social network', 'w': 0.46224}, {'name': 'Computer science', 'w': 0.43426}, {'name': 'Popularity', 'w': 0.52745}, {'name': 'Probabilistic logic', 'w': 0.44729}, {'name': 'Attendance', 'w': 0.4715}, {'name': 'Personalization', 'w': 0.49419}], 'venue': {'raw': 'Conference on Information and Knowledge Management', 'id': 1194094125, 'type': 'C'}, 'abstract': 'Location-based social networks (LBSNs), such as Foursquare, fostered the emergence of new tasks such as recommending venues a user might wish to visit. In the literature, recommending venues has typically been addressed using user-centric recommendation approaches relying on collaborative filtering techniques. Such approaches not only require many users with detailed profiles to be effective, but they also cannot recommend venues to users who are not actually members of the LBSN. In contrast, in this paper, we introduce a venue-centric yet personalised probabilistic approach that suggests personalised and popular venues for users to visit in the near future. In our approach, we probabilistically incorporate two components, a popularity component for predicting the popularity of a venue at a given point in time, as estimated from the attendance of the venue in the LBSN (i.e. number of check-ins), and a personalisation component for identifying its interestingness with respect to the estimated preferences of the user. The popularity of each venue is predicted using time series forecasting models that are trained on the recent attendance trends of the venue, while the usersu0027 interests are modelled from the entity pages that they like on Facebook. Using three major cities, we conduct a user study to evaluate the effectiveness of the two components of our approach in suggesting venues for different types of users at different times of the day. Our experimental results show that an approach that combines the popularity and personalisation components is able to consistently outperform the recommendation service of the leading Foursquare LBSN. We also find that combining popularity and personalisation is effective for both new visitors and residents, while former visitors prefer popular venues. ', 'nb_references': 37, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 2295976769, 'authors': [{'name': 'Thibaut Thonet', 'org': 'Institut de recherche en informatique de Toulouse', 'id': 1667633116}, {'name': 'Romain Deveaud', 'org': '#N#University of Glasgow#N#', 'id': 314381667}, {'name': 'Iadh Ounis', 'org': '#N#University of Glasgow#N#', 'id': 336997814}, {'name': 'Craig Macdonald', 'org': '#N#University of Glasgow#N#', 'id': 2148910894}], 'title': 'Suggestion contextuelle composite', 'year': 2015, 'n_citation': 0, 'page_start': '89', 'page_end': '104', 'doc_type': '', 'publisher': "Association Francophone de Recherche d'Information et Applications (ARIA)", 'volume': '', 'issue': '', 'doi': '', 'references': [14425504, 36361912, 642387756, 1988144039, 1990184998, 1998683369, 2023188792, 2025605741, 2090909419, 2124555297, 2132314908, 2133777313, 2146081744, 2155304699, 2155912844, 2294660937, 2296693058, 2398871325], 'fos': [{'name': 'Sociology', 'w': 0.31855}, {'name': 'Humanities', 'w': 0.38591}, {'name': 'Art history', 'w': 0.32421}], 'venue': {'raw': 'CORIA'}, 'abstract': 'La suggestion contextuelle consiste a recommander a un utilisateur un ensemble de lieux du0027activites adaptes a ses preferences et a son contexte. La plupart des approches existantes considerent uniquement ces deux caracteristiques pour constituer leur liste de suggestions. Cependant, les recherches en systemes de recommandation ont recemment souligne lu0027importance de la diversite des suggestions. Cet article presente un modele novateur de suggestion contextuelle inspire de la recherche composite qui consiste a regrouper les suggestions en differentes grappes thematiquement cohesives. Lu0027evaluation realisee dans le cadre de la piste Contextual Suggestion de TREC 2013 et 2014 montre que notre approche est competitive et permet du0027ameliorer la diversite des suggestions sans degrader leur pertinence. ', 'nb_references': 18, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 2398986806, 'authors': [{'name': 'Romain Deveaud', 'org': 'University of Avignon', 'id': 314381667}, {'name': 'Florian Boudin', 'org': 'Univ. of Nantes#TAB#', 'id': 1982546398}], 'title': 'Effective Tweet Contextualization with Hashtags Performance Prediction and Multi-Document Summarization.', 'year': 2013, 'n_citation': 9, 'page_start': '', 'page_end': '', 'doc_type': '', 'publisher': '', 'volume': '', 'issue': '', 'doi': '', 'references': [1525595230, 2070740689, 2296680460, 2403913205], 'fos': [{'name': 'Automatic summarization', 'w': 0.6701}, {'name': 'Multi-document summarization', 'w': 0.63853}, {'name': 'Information retrieval', 'w': 0.46972}, {'name': 'Computer science', 'w': 0.43245}, {'name': 'Preprocessor', 'w': 0.4387}, {'name': 'Contextualization', 'w': 0.49303}, {'name': 'Performance prediction', 'w': 0.38809}, {'name': 'Sentence', 'w': 0.48056}], 'venue': {'raw': 'CLEF (Working Notes)'}, 'abstract': 'In this paper we describe our participation in the INEX 2013 Tweet Contextualization track and present our contributions. Our approach is the same as last year, and is composed of three main components: preprocessing, Wikipedia articles retrieval and multi-document summarization. We however took advantage of a larger use of hashtags in the topics and used them to enhance the retrieval of relevant Wikipedia articles. We also took advantage of the training examples from last year which allowed us to learn the weights of each sentence selection feature. Two of our submitted runs achieved the two best informativeness results, while our generated contexts where almost as readable as those of the most readable system. ', 'nb_references': 4, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 1988144039, 'authors': [{'name': 'Romain Deveaud', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 314381667}, {'name': 'M-Dyaa Albakour', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 209705036}, {'name': 'Craig Macdonald', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 2148910894}, {'name': 'Iadh Ounis', 'org': '†University of Glasgow, Glasgow, United Kingdom', 'id': 336997814}], 'title': 'On the Importance of Venue-Dependent Features for Learning to Rank Contextual Suggestions', 'year': 2014, 'n_citation': 14, 'page_start': '1827', 'page_end': '1830', 'doc_type': 'Conference', 'publisher': 'ACM', 'volume': '', 'issue': '', 'doi': '10.1145/2661829.2661956', 'references': [36361912, 642387756, 1845198550, 1970449205, 1987425720, 2090909419, 2106421124, 2117446354, 2124555297, 2133777313, 2142537246, 2143331230, 2149427297, 2166646729, 2296693058], 'fos': [{'name': 'Data mining', 'w': 0.44174}, {'name': 'Learning to rank', 'w': 0.56498}, {'name': 'Information retrieval', 'w': 0.47009}, {'name': 'Computer science', 'w': 0.44698}, {'name': 'Language modelling', 'w': 0.0}, {'name': 'Personalization', 'w': 0.48993}], 'venue': {'raw': 'Conference on Information and Knowledge Management', 'id': 1194094125, 'type': 'C'}, 'abstract': 'Suggesting venues to a user in a given geographic context is an emerging task that is currently attracting a lot of attention. Existing studies in the literature consist of approaches that rank candidate venues based on different features of the venues and the user, which either focus on modeling the preferences of the user or the quality of the venue. However, while providing insightful results and conclusions, none of these studies have explored the relative effectiveness of these different features. In this paper, we explore a variety of user-dependent and venue-dependent features and apply state-of-the-art learning to rank approaches to the problem of contextual suggestion in order to find what makes a venue relevant for a given context. Using the test collection of the TREC 2013 Contextual Suggestion track, we perform a number of experiments to evaluate our approach. Our results suggest that a learning to rank technique can significantly outperform a Language Modelling baseline that models the positive and negative preferences of the user. Moreover, despite the fact that the contextual suggestion task is a personalisation task (i.e. providing the user with personalised suggestions of venues), we surprisingly find that user-dependent features are less effective than venue-dependent features for estimating the relevance of a suggestion. ', 'nb_references': 15, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 2250458380, 'authors': [{'name': 'Romain Deveaud', 'org': "Laboratoire Informatique d'Avignon", 'id': 314381667}, {'name': 'Eric SanJuan', 'org': "Laboratoire Informatique d'Avignon", 'id': 2811480703}, {'name': 'Patrice Bellot', 'org': "Laboratoire des Sciences de l'Information et des Systèmes", 'id': 2133591691}], 'title': 'Are Semantically Coherent Topic Models Useful for Ad Hoc Information Retrieval', 'year': 2013, 'n_citation': 7, 'page_start': '148', 'page_end': '152', 'doc_type': 'Conference', 'publisher': '', 'volume': '', 'issue': '', 'doi': '', 'references': [171181878, 1585938933, 1880262756, 1964348731, 1972594981, 2042980227, 2076683968, 2087743880, 2129891468, 2130324521, 2130339025, 2134731454, 2147152072, 2147946282, 2155188720, 2169213601], 'fos': [{'name': 'Latent Dirichlet allocation', 'w': 0.70352}, {'name': 'Information retrieval', 'w': 0.47214}, {'name': 'Computer science', 'w': 0.4492}, {'name': 'Coherence (physics)', 'w': 0.48335}, {'name': 'Artificial intelligence', 'w': 0.0}, {'name': 'Probabilistic latent semantic analysis', 'w': 0.70673}, {'name': 'Natural language processing', 'w': 0.47149}, {'name': 'Topic model', 'w': 0.63903}, {'name': 'Machine learning', 'w': 0.46443}], 'venue': {'raw': 'Meeting of the Association for Computational Linguistics', 'id': 1188739475, 'type': 'C'}, 'abstract': 'The current topic modeling approaches for Information Retrieval do not allow to explicitly model query-oriented latent topics. More, the semantic coherence of the topics has never been considered in this field. We propose a model-based feedback approach that learns Latent Dirichlet Allocation topic models on the top-ranked pseudo-relevant feedback, and we measure the semantic coherence of those topics. We perform a first experimental evaluation using two major TREC test collections. Results show that retrieval performances tend to be better when using topics with higher semantic coherence. ', 'nb_references': 16, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 2006604430, 'authors': [{'name': 'Romain Deveaud', 'org': 'School of Computing Science [Glasgow, Scotland]', 'id': 314381667}, {'name': 'Eric SanJuan', 'org': "Laboratoire Informatique d'Avignon", 'id': 2811480703}, {'name': 'Patrice Bellot', 'org': "Laboratoire des Sciences de l'Information et des Systèmes", 'id': 2133591691}], 'title': 'Accurate and effective latent concept modeling for ad hoc information retrieval', 'year': 2014, 'n_citation': 64, 'page_start': '61', 'page_end': '84', 'doc_type': '', 'publisher': 'Lavoisier', 'volume': '17', 'issue': '1', 'doi': '10.3166/dn.17.1.61-84', 'references': [197926473, 1585938933, 1685426458, 1880262756, 1927727507, 1969949308, 1972594981, 1999822363, 2007585013, 2014415866, 2015441003, 2022166150, 2034076209, 2042980227, 2044434631, 2052088591, 2053921957, 2070740689, 2076683968, 2087743880, 2093605115, 2099868020, 2099871636, 2103522185, 2104373244, 2107370612, 2110642088, 2111216736, 2129891468, 2134731454, 2135175918, 2137222670, 2147152072, 2147946282, 2155188720, 2169213601, 2250458380, 2294145134, 2403913205], 'fos': [{'name': 'Sociology', 'w': 0.31264}, {'name': 'Humanities', 'w': 0.37635}, {'name': 'Art history', 'w': 0.31821}], 'venue': {'raw': 'Document numérique'}, 'abstract': 'Une requete est la representation du besoin d’information d’un utilisateur, et est le resultat d’un processus cognitif complexe qui mene souvent a un mauvais choix de mots-cles. Nous proposons une methode non supervisee pour la modelisation de concepts implicites d’une requete, dans le but de recreer la representation conceptuelle du besoin d’information initial. Nous utilisons l’allocation de Dirichlet latente (LDA) pour detecter les concepts implicites de la requete en utilisant des documents pseudo-pertinents. Nous evaluons cette methode en profondeur en utilisant deux collections de test de TREC. Nous trouvons notamment que notre approche permet de modeliser precisement les concepts implicites de la requete, tout en obtenant de bonnes performances dans le cadre d’une recherche de documents. ', 'nb_references': 39, 'author': {'name': '', 'id': '', 'org': ''}}
# {'id': 101942651, 'authors': [{'name': 'Romain Deveaud', 'id': 314381667}, {'name': 'Florian Boudin', 'id': 1982546398}, {'name': 'Eric SanJuan', 'id': 2954435341}, {'name': 'Patrice Bellot', 'org': 'University of Avignon', 'id': 2133591691}], 'title': 'Correction de césures et enrichissement de requêtes pour la recherche de livres.', 'year': 2011, 'n_citation': 1, 'page_start': '89', 'page_end': '96', 'doc_type': '', 'publisher': '', 'volume': '', 'issue': '', 'doi': '', 'references': [1542082471, 1979459060, 1979898007, 2007585013, 2053526805, 2081227797, 2085763602, 2087499664, 2093390569, 2107038821, 2127452535, 2136542423], 'fos': [{'name': 'Query expansion', 'w': 0.64598}, {'name': 'Information retrieval', 'w': 0.44763}, {'name': 'Computer science', 'w': 0.40805}], 'venue': {'raw': 'CORIA'}, 'abstract': 'Digitized books are now a common source of information on the Web, however OCR sometimes introduces errors that can penalize Information Retrieval. In this paper we propose a method for correcting hyphenations and we analyse its impact on a standard book retrieval task. We also experiment query expansion with words extracted from the Wikipedia page related to the query. We show that there is a significant improvement over the state-of-the-art when using a large weighted list of words. MOTS-CLES : Livres numerises, cesures, enrichissement de requete, Wikipedia. ', 'nb_references': 12}
# {'id': 2251784847, 'authors': [{'name': 'Romain Deveaud', 'id': 314381667}, {'name': 'Patrice Bellot', 'id': 2133591691}], 'title': "Combinaison de ressources g'en'erales pour une contextualisation implicite de requ^etes (Query Contextualization and Reformulation by Combining External Corpora) [in French]", 'year': 2012, 'n_citation': 0, 'page_start': '479', 'page_end': '486', 'doc_type': '', 'publisher': '', 'volume': '', 'issue': '', 'doi': '', 'fos': [{'name': 'Sociology', 'w': 0.34489}, {'name': 'Humanities', 'w': 0.38369}, {'name': 'Contextualization', 'w': 0.52641}], 'venue': {'raw': 'Proceedings of the Joint Conference JEP-TALN-RECITAL 2012, volume 2: TALN'}, 'abstract': '', 'references': '', 'nb_references': 0}
#
# Process finished with exit code 0